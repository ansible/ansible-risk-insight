# {{ ansible_managed }}

{% set used_lvm_devices = [] %}
{% set lv_devices = lvm_devices.stdout.split('\n') %}
{% if lv_devices|length > 0 %}
    {% for net in lv_devices %}
        {% if net != '' %}
            {% set lv_device = '"a/' + net + '/"' %}
            {% if used_lvm_devices.append(lv_device) %}{% endif %}
        {% endif %}
    {% endfor %}
{% endif %}

# Ansible Discovered LVM Devices {{ lv_devices }}

{% if used_lvm_devices|length <= 0 %}
    {# If there are no LVM devices present, allow all devices to be scanned #}
    {% if used_lvm_devices.append('"a/.*/"') %}{% endif %}
{% else %}
    {# Append 'loop.*' to the list to help with AIO deployments. #}
    {% if used_lvm_devices.append('"a/loop.*/"') %}{% endif %}
    {# Disable scanning any other devices than the ones listed. #}
    {% if used_lvm_devices.append('"r/.*/"') %}{% endif %}
{% endif %}

devices {
    dir = "/dev"
    scan = [ "/dev" ]
    obtain_device_list_from_udev = 1
    preferred_names = [ ]
    filter = [ {{ used_lvm_devices|join(', ') }} ]
    cache_dir = "/run/lvm"
    cache_file_prefix = ""
    write_cache_state = 1
    sysfs_scan = 1
    multipath_component_detection = 1
    md_component_detection = 1
    md_chunk_alignment = 1
    data_alignment_detection = 1
    data_alignment = 0
    data_alignment_offset_detection = 1
    ignore_suspended_devices = 0
    disable_after_error_count = 0
    require_restorefile_with_uuid = 1
    pv_min_size = 2048
    issue_discards = 1
}
allocation {
    maximise_cling = 1
    mirror_logs_require_separate_pvs = 0
    thin_pool_metadata_require_separate_pvs = 0
}
log {
    verbose = 0
    silent = 0
    syslog = 1
    overwrite = 0
    level = 0
    indent = 1
    command_names = 0
    prefix = "  "
}
data {
    data = 1
    data_dir = "/etc/lvm/data"
    archive = 1
    archive_dir = "/etc/lvm/archive"
    retain_min = 10
    retain_days = 30
}
shell {
    history_size = 100
}
global {
    umask = 077
    test = 0
    units = "h"
    si_unit_consistency = 1
    activation = 1
    proc = "/proc"
    locking_type = 1
    wait_for_locks = 1
    fallback_to_clustered_locking = 1
    fallback_to_local_locking = 1
    locking_dir = "/run/lock/lvm"
    prioritise_write_locks = 1
    abort_on_internal_errors = 0
    detect_internal_vg_cache_corruption = 0
    metadata_read_only = 0
    mirror_segtype_default = "mirror"
    use_lvmetad = 0
    thin_check_executable = "/usr/sbin/thin_check"
    thin_check_options = [ "-q" ]
}
activation {
    checks = 0
    udev_sync = 1
    udev_rules = 1
    verify_udev_operations = 0
    retry_deactivation = 1
    missing_stripe_filler = "error"
    use_linear_target = 1
    reserved_stack = 64
    reserved_memory = 8192
    process_priority = -18
    mirror_region_size = 512
    readahead = "auto"
    raid_fault_policy = "warn"
    mirror_log_fault_policy = "allocate"
    mirror_image_fault_policy = "remove"
    snapshot_autoextend_threshold = 100
    snapshot_autoextend_percent = 20
    thin_pool_autoextend_threshold = 100
    thin_pool_autoextend_percent = 20
    use_mlockall = 0
    monitoring = 0
    polling_interval = 15
}
dmeventd {
    mirror_library = "libdevmapper-event-lvm2mirror.so"
    snapshot_library = "libdevmapper-event-lvm2snapshot.so"
    thin_library = "libdevmapper-event-lvm2thin.so"
}
